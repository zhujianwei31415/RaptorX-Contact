from __future__ import absolute_import, division, print_function

import numpy as np
import os
import sys

try:
    import cPickle as pickle
except:
    import pickle



"""
This script reads an hhm file generated by the HHpred/HHblits package to
generate position-specific scoring/frequency matrix, and after reading
an .hhm file, this script stores the HMM as a python dict():
1) To use the position-specific frequency matrix, please use the keyword PSFM.
2) To use the position-specific scoring matrix, please use the keyword PSSM.
Both PSFM and PSSM encode information derived from the profile HMM built by
HHpred or HHblits, so there is no need to directly use the keys containing 'hmm'
PSFM and PSSM columns are arranged by the alphabetical order of amino acids
in their 1-letter code
"""
# secondary strcuture conversion with 8-state labels
SS8Letter2Code = {'H':0, 'G':1, 'I':2, 'E':3, 'B':4, 'T':5, 'S':6, 'L':7, 'C':7}

# secondary structure conversion with 3-state labels
# note here HELIX, BETA and LOOP correspond to 1, 2 and 0, respectively
SS8Letter2SS3Code = {'H':0, 'G':0, 'I':0, 'E':1, 'B':1, 'T':2, 'S':2, 'L':2, 'C':2}

# AA3LetterCode is the alphabetical order of amino acids by its 3-letter code
AA3LetterCode=['ALA', 'ARG', 'ASN', 'ASP', 'ASX', 'CYS', 'GLU', 'GLN', 'GLX', 'GLY', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE', 'PRO', 'SER', 'THR', 'TRY', 'TYR', 'VAL']

# AA1LetterCode is the 1-letter code of amino acids by its 3-letter code
AA1LetterCode=['A',   'R',   'N',   'D',   'B',   'C',   'E',   'Q',   'Z',   'G',   'H',   'I',   'L',   'K',   'M',   'F',   'P',   'S',   'T',   'W',   'Y',   'V'  ]

# only allow 20 amino acids in our protein sequences
ValidAALetters=set(['A', 'R', 'N',  'D', 'C', 'E', 'Q', 'G',  'H',  'I',  'L',  'K',  'M',  'F',  'P',  'S',  'T',  'W',  'Y',  'V'])

# map the two rare amino acids to index 20
# AAOrderBy3Letter is the alphabetical order of amino acids by its 3-letter code
AAOrderBy3Letter=[0, 1, 2, 3, 20, 4, 5, 6, 20, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

# map the two rare amino acids to index 20
# AAOrderBy1Letter is the alphabetical order of amino acids by its 1-letter code
AAOrderBy1Letter=[0, 14, 11, 2, 20, 1, 3, 13, 20, 5, 6, 7, 9, 8, 10, 4, 12, 15, 16, 18, 19, 17]

# mapping between 1-letter code and 3-letter code
AA3LetterCode21LetterCode = {}
AA1LetterCode23LetterCode = {}

# map from one AA (3- or 1-letter code) to its order in terms of 3-letter code
AALetter2OrderOf3LetterCode = {}

# map from one AA (3- or 1-letter code) to its order in terms of 1-letter code
AALetter2OrderOf1LetterCode = {}

# map between 3-letter order and 1-letter order
AA3LetterOrder21LetterOrder = {}
AA1LetterOrder23LetterOrder = {}

# map 3- or 1-letter code with index
for l3, l1, o3, o1 in zip(AA3LetterCode, AA1LetterCode, AAOrderBy3Letter, AAOrderBy1Letter):
    AA1LetterCode23LetterCode[l1] = l3
    AA3LetterCode21LetterCode[l3] = l1

    AALetter2OrderOf3LetterCode[l1] = o3
    AALetter2OrderOf3LetterCode[l3] = o3

    AALetter2OrderOf1LetterCode[l1] = o1
    AALetter2OrderOf1LetterCode[l3] = o1

    AA3LetterOrder21LetterOrder[o3] = o1
    AA1LetterOrder23LetterOrder[o1] = o3

# the rows and cols of gonnet matrix are arranged in the alpahbetical oder of
# amino acids in the 3-letter code
# the below matrix is a mutation probability matrix?
gonnet = [
[ 1.7378,  0.870964,0.933254,0.933254, 1.12202,  0.954993, 1,        1.12202,  0.831764, 0.831764,  0.758578, 0.912011, 0.851138, 0.588844, 1.07152,  1.28825,  1.14815,   0.436516,  0.60256,  1.02329],
[ 0.870964,2.95121, 1.07152, 0.933254, 0.60256,  1.41254,  1.09648,  0.794328, 1.14815,  0.57544,   0.60256,  1.86209,  0.676083, 0.47863,  0.812831, 0.954993, 0.954993,  0.691831,  0.660693, 0.630957],
[ 0.933254,1.07152, 2.39883, 1.65959,  0.660693, 1.1749,   1.23027,  1.09648,  1.31826,  0.524807,  0.501187, 1.20226,  0.60256,  0.489779, 0.812831, 1.23027,  1.12202,   0.436516,  0.724436, 0.60256],
[ 0.933254,0.933254,1.65959, 2.95121,  0.47863,  1.23027,  1.86209,  1.02329,  1.09648,  0.416869,  0.398107, 1.12202,  0.501187, 0.354813, 0.851138, 1.12202,  1,         0.301995,  0.524807, 0.512861],
[ 1.12202, 0.60256, 0.660693,0.47863, 14.1254,   0.57544,  0.501187, 0.630957, 0.74131,  0.776247,  0.707946, 0.524807, 0.812831, 0.831764, 0.489779, 1.02329,  0.891251,  0.794328,  0.891251, 1],
[ 0.954993,1.41254, 1.1749,  1.23027,  0.57544,  1.86209,  1.47911,  0.794328, 1.31826,  0.645654,  0.691831, 1.41254,  0.794328, 0.549541, 0.954993, 1.04713,  1,         0.537032,  0.676083, 0.707946],
[ 1,       1.09648, 1.23027, 1.86209,  0.501187, 1.47911,  2.29087,  0.831764, 1.09648,  0.537032,  0.524807, 1.31826,  0.630957, 0.40738,  0.891251, 1.04713,  0.977237,  0.371535,  0.537032, 0.645654],
[ 1.12202, 0.794328,1.09648, 1.02329,  0.630957, 0.794328, 0.831764, 4.57088,  0.724436, 0.354813,  0.363078, 0.776247, 0.446684, 0.301995, 0.691831, 1.09648,  0.776247,  0.398107,  0.398107, 0.467735],
[ 0.831764,1.14815, 1.31826, 1.09648,  0.74131,  1.31826,  1.09648,  0.724436, 3.98107,  0.60256,   0.645654, 1.14815,  0.74131,  0.977237, 0.776247, 0.954993, 0.933254,  0.831764,  1.65959,  0.630957],
[ 0.831764,0.57544, 0.524807,0.416869, 0.776247, 0.645654, 0.537032, 0.354813, 0.60256,  2.51189,   1.90546,  0.616595, 1.77828,  1.25893,  0.549541, 0.660693, 0.870964,  0.660693,  0.851138, 2.04174],
[ 0.758578,0.60256, 0.501187,0.398107, 0.707946, 0.691831, 0.524807, 0.363078, 0.645654, 1.90546,   2.51189,  0.616595, 1.90546,  1.58489,  0.588844, 0.616595, 0.74131,   0.851138,  1,        1.51356],
[ 0.912011,1.86209, 1.20226, 1.12202,  0.524807, 1.41254,  1.31826,  0.776247, 1.14815,  0.616595,  0.616595, 2.0893,   0.724436, 0.467735, 0.870964, 1.02329,  1.02329,   0.446684,  0.616595, 0.676083],
[ 0.851138,0.676083,0.60256, 0.501187, 0.812831, 0.794328, 0.630957, 0.446684, 0.74131,  1.77828,   1.90546,  0.724436, 2.69153,  1.44544,  0.57544,  0.724436, 0.870964,  0.794328,  0.954993, 1.44544],
[ 0.588844,0.47863, 0.489779,0.354813, 0.831764, 0.549541, 0.40738,  0.301995, 0.977237, 1.25893,   1.58489,  0.467735, 1.44544,  5.01187,  0.416869, 0.524807, 0.60256,   2.29087,   3.23594,  1.02329],
[ 1.07152, 0.812831,0.812831,0.851138, 0.489779, 0.954993, 0.891251, 0.691831, 0.776247, 0.549541,  0.588844, 0.870964, 0.57544,  0.416869, 5.7544,   1.09648,  1.02329,   0.316228,  0.489779, 0.660693],
[ 1.28825, 0.954993,1.23027, 1.12202,  1.02329,  1.04713,  1.04713,  1.09648,  0.954993, 0.660693,  0.616595, 1.02329,  0.724436, 0.524807, 1.09648,  1.65959,  1.41254,   0.467735,  0.645654, 0.794328],
[ 1.14815, 0.954993,1.12202, 1,        0.891251, 1,        0.977237, 0.776247, 0.933254, 0.870964,  0.74131,  1.02329,  0.870964, 0.60256,  1.02329,  1.41254,  1.77828,   0.446684,  0.645654, 1],
[ 0.436516,0.691831,0.436516,0.301995, 0.794328, 0.537032, 0.371535, 0.398107, 0.831764, 0.660693,  0.851138, 0.446684, 0.794328, 2.29087,  0.316228, 0.467735, 0.446684, 26.3027,    2.5704,   0.549541],
[ 0.60256, 0.660693,0.724436,0.524807, 0.891251, 0.676083, 0.537032, 0.398107, 1.65959,  0.851138,  1,        0.616595, 0.954993, 3.23594,  0.489779, 0.645654, 0.645654,  2.5704,    6.0256,   0.776247],
[ 1.02329, 0.630957,0.60256, 0.512861, 1,        0.707946, 0.645654, 0.467735, 0.630957, 2.04174,   1.51356,  0.676083, 1.44544,  1.02329,  0.660693, 0.794328, 1,         0.549541,  0.776247, 2.18776]
]
gonnet = np.array(gonnet, np.float32)

# index for HMM state transition
M_M, M_I, M_D, I_M, I_I, D_M, D_D, _NEFF, I_NEFF, D_NEFF = 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

# HMMNull is the background score of amino acids, in the alphabetical order of 1-letter code
HMMNull = [3706,5728,4211,4064,4839,3729,4763,4308,4069,3323,5509,4640,4464,4937,4285,4423,3815,3783,6325,4665,0]
HMMNull = np.array(HMMNull, dtype=np.float32)


# this function reads the HMM block from a profleHMM file, which is
# generated by HHpred/HHblits package, and the header has 4 lines
def ReadHHM(lines, start_position, length, one_protein, numLines4Header=4):
    # skip the header
    i = start_position
    one_protein['HMMHeader'] = lines[i: i+ numLines4Header]
    i += numLines4Header

    # the columns of hmm1 are in the alphabetical order of amino acids
    # in 1-letter code, different from the above PSP and PSM matrices
    one_protein['hmm1'] = np.zeros( (length, 20), np.float32)
    one_protein['hmm2'] = np.zeros( (length, 10), np.float32)
    one_protein['hmm1_prob'] = np.zeros((length, 20), np.float32)
    one_protein['hmm1_score'] = np.zeros((length, 20), np.float32)

    # empty sequence for storing amino acid type
    seqStr = ''

    # read in data line by line
    for l in range(length):
        # this line is for emission score. The amino acids are ordered from
        # left to right alphabetically by their 1-letter code
        fields = lines[ i + l*3 + 0].replace('*', '99999').split()
        assert len(fields) == 23, 'ERROR: wrong number of emission score'
        one_protein['hmm1'][l] = np.array([ - np.int32(num) for num in fields[2: -1] ])/1000.
        aa = fields[0]
        seqStr += aa
        #if  (l + 1) != np.int32(fields[1]):
        #    sys.exit('Error: inconsistent residue number in file for protein %s at line: %s' % (one_protein['name'], lines[ i + l*3 + 0 ]))

        # the first 7 columns of this line is for state transition
        one_protein['hmm2'][l][0:7] = [ np.exp(-np.int32(num)/1000.0*0.6931) for num in lines[i + l*3 + 1].replace("*", "99999").split()[0:7]]

        # the last 3 columns of this line is for Neff of Match, Insertion and Deletion
        one_protein['hmm2'][l][7:10] = [ np.int32(num)/1000.0 for num in lines[i + l*3 + 1].split()[7:10]]

        # _NEFF is for match, I_NEFF for insertion and D_NEFF for deletion.
        # More comments are needed for the below code.
        rm = 0.1
        one_protein['hmm2'][l][M_M] = (one_protein['hmm2'][l][_NEFF]*one_protein['hmm2'][l][M_M] + rm*0.6)/(rm + one_protein['hmm2'][l][_NEFF])
        one_protein['hmm2'][l][M_I] = (one_protein['hmm2'][l][_NEFF]*one_protein['hmm2'][l][M_I] + rm*0.2)/(rm + one_protein['hmm2'][l][_NEFF])
        one_protein['hmm2'][l][M_D] = (one_protein['hmm2'][l][_NEFF]*one_protein['hmm2'][l][M_D] + rm*0.2)/(rm + one_protein['hmm2'][l][_NEFF])

        ri = 0.1
        one_protein['hmm2'][l][I_I] = (one_protein['hmm2'][l][I_NEFF]*one_protein['hmm2'][l][I_I] + ri*0.75)/(ri + one_protein['hmm2'][l][I_NEFF])
        one_protein['hmm2'][l][I_M] = (one_protein['hmm2'][l][I_NEFF]*one_protein['hmm2'][l][I_M] + ri*0.25)/(ri + one_protein['hmm2'][l][I_NEFF])

        rd = 0.1
        one_protein['hmm2'][l][D_D] = (one_protein['hmm2'][l][D_NEFF]*one_protein['hmm2'][l][D_D] + rd*0.75)/(rd + one_protein['hmm2'][l][D_NEFF])
        one_protein['hmm2'][l][D_M] = (one_protein['hmm2'][l][D_NEFF]*one_protein['hmm2'][l][D_M] + rd*0.25)/(rd + one_protein['hmm2'][l][D_NEFF])

        one_protein['hmm1_prob'][l,] = pow(2.0, one_protein['hmm1'][l,])
        wssum = sum(one_protein['hmm1_prob'][l, ])

        #print('l=', l, 'sum=', wssum)

        # renormalize to make wssum = 1
        if wssum > 0 :
            one_protein['hmm1_prob'][l, ] /= wssum
        else:
            one_protein['hmm1_prob'][l, AALetter2OrderOf1LetterCode[aa] ] = 1.

        """
        # if the probability sum is not equal to 1
        if abs(wssum - 1.) > 0.1 :
            one_protein['hmm1_prob'][l, ] = 0
            one_protein['hmm1_prob'][l, AALetter2OrderOf1LetterCode[aa] ] = 1.
        """

        # add pseudo count
        g = np.zeros( (20), np.float32)
        for j in range(20):
            orderIn3LetterCode_j = AA1LetterOrder23LetterOrder[j]
            for k in range(20):
                orderIn3LetterCode_k = AA1LetterOrder23LetterOrder[k]
                g[j] += one_protein['hmm1_prob'][l, k] * gonnet[ orderIn3LetterCode_k, orderIn3LetterCode_j ]
            g[j] *= pow(2.0, -1.0*HMMNull[j] / 1000.0)

        #print('l=', l, 'gsum=', sum(g))
        # sum(g) is very close to 1, here we renormalize g to make its sum to be exactly 1
        g = g/sum(g)

        ws_tmp_neff = one_protein['hmm2'][l][_NEFF] - 1
        one_protein['hmm1'][l, ] = (ws_tmp_neff * one_protein['hmm1_prob'][l, ] + g*10) / (ws_tmp_neff+10)

        # recalculate the emission score and probability after pseudo count is added
        one_protein['hmm1_prob'][l,] = one_protein['hmm1'][l, ]
        one_protein['hmm1'][l, ] = np.log2(one_protein['hmm1_prob'][l, ])
        one_protein['hmm1_score' ][l, ] = one_protein['hmm1'][l, ] + HMMNull[:20]/1000.0

        # PSFM: position-specific frequency matrix
        # PSSM: position-specific scoring matrix
        one_protein['PSFM'] = one_protein['hmm1_prob']
        one_protein['PSSM'] = one_protein['hmm1_score']

    #assert ( seqStr == one_protein['sequence'] )
    if len(seqStr) != len(one_protein['sequence']):
        sys.exit('ERROR: inconsistent sequence length in HMM section and orignal sequence for protein: %s' % one_protein['name'])

    comparison = [ (aa=='X' or bb=='X' or aa==bb) for aa, bb in zip(seqStr, one_protein['sequence']) ]
    if not all(comparison):
        sys.exit('ERROR: inconsistent sequence between HMM section and orignal sequence for protein: %s' % one_protein['name'])

    return i + 3*length, one_protein


# this function reads a profile HMM file generated by HHpred/HHblits package
def LoadHHM(hhmfile):
    # check .hhm file format
    with open(hhmfile, 'r') as fh:
        content = [ r.strip() for r in list(fh) ]
    if not bool(content):
        sys.exit('ERROR: empty profileHMM file: %s' % hhmfile)
    if not content[0].startswith('HHsearch'):
        sys.exit('ERROR: this file may not be a profileHMM file generated by HHpred/HHblits: %s' % hhmfile)
    if len(content) < 10:
        sys.exit('ERROR: this profileHMM file is too short: %s' % hhmfile)

    # protein section in .hhm file
    requiredSections = ['name', 'length', 'sequence', 'NEFF',  'hmm1', 'hmm2', 'hmm1_prob', 'hmm1_score', 'PSFM', 'PSSM', 'DateCreated']
    protein = {}

    # get sequence name
    if not content[1].startswith('NAME '):
        sys.exit('ERROR: the protein name shall appear at the second line of profileHMM file: %s' % hhmfile)
    fields = content[1].split()
    if len(fields) < 2:
        sys.exit('ERROR: incorrect name format in profileHMM file: %s' % hhmfile)
    protein['name'] = fields[1]

    # get overall information of .hhm file
    i = 0
    while i < len(content):
        row = content[i]
        if len(row)<1:
            i += 1
            continue

        if row.startswith('DATE '):
            protein['DateCreated'] = row[6:]
            i += 1
            continue

        if row.startswith('NEFF '):
            protein['NEFF'] = np.float32(row.split()[1])
            i += 1
            continue

        if row.startswith('LENG '):
            protein['length'] = np.int32(row.split()[1])
            i += 1
            continue

        if row.startswith('>ss_pred'):
            # read the predicted secondary structure
            start = i+1
            end = i+1
            while not content[end].startswith('>'):
                end += 1
            protein['SSEseq'] = ''.join(content[start:end]).replace('C', 'L')
            if len(protein['SSEseq']) != protein['length']:
                sys.exit('ERROR: inconsistent sequence length and predicted SS sequence length in hhmfile: %s' % hhmfile)
            i = end
            continue

        if row.startswith('>ss_conf'):
            # read the predicted secondary structure confidence score
            start = i+1
            end = i+1
            while not content[end].startswith('>'):
                end += 1

            SSEconfStr = ''.join(content[start:end])
            protein['SSEconf'] = [ np.int16(score) for score in SSEconfStr ]

            if len(protein['SSEconf']) != protein['length']:
                sys.exit('ERROR: inconsistent sequence length and predicted SS confidence sequence length in hhmfile: %s' % hhmfile)

            i = end
            continue

        if row.startswith('>' + protein['name']):
            # read in the sequence in the following lines
            start = i+1
            end = i+1
            while (not content[end].startswith('>')) and (not content[end].startswith('#')):
                end += 1

            # at this point, content[end] shall start with >
            protein['sequence'] = ''.join(content[start:end])
            if len(protein['sequence']) != protein['length']:
                sys.exit('ERROR: inconsistent sequence length in hhmfile: %s' % hhmfile)
            i = end
            continue

        if len(row) == 1 and row[0]=='#' and content[i+1].startswith('NULL') and content[i+2].startswith('HMM'):
            i, protein = ReadHHM(content, i+1, protein['length'], protein, numLines4Header=4)
            continue

        i += 1

    # double check to see some required sections are read in
    for section in requiredSections:
        if section not in protein:
            sys.exit('ERROR: one section for %s is missing in the hmm file: %s' % (section, hhmfile))

    protein['requiredSections'] = requiredSections

    return protein
"""
End of reading an hhm file generated by the HHpred/HHblits package.
"""




# in the future we may add some code to check correctness
def Load1DFeatureFromFile(file, seqName=None, seq=None):
    # check input feature file
    if not os.path.isfile(file):
        sys.exit('ERROR: cannot find the 1D feature file %s' % file)
    # read in data from file
    allprobs, AAs = [], []
    with open(file, 'r') as fin:
        for line in fin:
            line = line.strip()
            if len(line) == 0 or line[0] == '#': continue
            array = line.split()
            assert len(array) == 4 or len(array) == 6 or len(array) == 11, (
                'ERROR: wrong file format for predicted 1D feature %s' % file)
            probs = [ np.float32(_) for _ in array[3:] ]
            allprobs.append(probs)
            AAs.append(array[1])
    AAs = ''.join(AAs)
    # check length
    if seq is not None:
        assert len(seq) == len(allprobs), 'ERROR: wrong length for %s' % file
        assert seq == AAs, 'ERROR: wrong sequence for %s' % file
    # convert probs to numpy array and check
    probs = np.array(allprobs)
    if np.isnan( np.sum(probs) ):
        sys.exit('ERROR: there are NaNs in file %s' % file)

    return probs


def LoadProfile(file, seqName=None, seq=None):
    # check input profile
    if not os.path.isfile(file):
        sys.exit('ERROR: cannot find temporary profile file %s' % file)
    # read in data from file
    fh = open(file, 'r')
    content = list(fh)
    fh.close()
    # check data format
    seqLen = int(content[1].strip())
    assert len(content) == (3 + 2*seqLen), 'ERROR: wrong length for %s' % file
    if seqName is not None:
        assert content[0].strip() == seqName, 'ERROR: wrong name for %s' % file
    if seq is not None:
        assert content[2].strip() == seq, 'ERROR: wrong sequence for %s' % file
    # convert PSFM to float
    allprobs = []
    for line in content[3 : 3+seqLen]:
        probs = [ np.float32(_) for _ in line.split(',') ]
        allprobs.append(probs)
    # convert PSSM to float
    allscores = []   
    for line in content[3+seqLen : 3+2*seqLen ]:
        scores = [ np.float32(_) for _ in line.split(',') ]
        allscores.append(scores)
    # convert list ot numpy array
    probs, scores = np.array(allprobs), np.array(allscores)
    if np.isnan( np.sum(probs) ) or np.isnan( np.sum(scores) ):
        sys.exit('ERROR: there are NaNs in file %s' % file)

    return probs, scores


def LoadECMatrix(file, seqName=None, seq=None):
    # check input profile
    if not os.path.isfile(file):
        sys.exit('ERROR: cannot find EC matrix file %s' % file)
    # read in data from file
    allECs = []
    with open(file, 'r') as fin:
        for line in fin:
            ECs = [ np.float16(_) for _ in line.split() ]
            if seq is not None:
                assert len(seq) == len(ECs), 'ERROR: wrong columns %s' % file
            allECs.append(ECs)
    if seq is not None:
        assert len(seq) == len(allECs), 'ERROR: wrong rows in %s' % file
    # convert list to numpy array
    ECMatrix = np.array(allECs)
    if np.isnan( np.sum(ECMatrix.astype(np.float32)) ):
        sys.exit('ERROR:, there is at least one NaN in %s' % file)

    return ECMatrix


def LoadOtherPairFeatures(file, seqName=None, seq=None):
    # check input potential file
    if not os.path.isfile(file):
        sys.exit('ERROR: cannot find contact potential file %s' % file)
    if seq is None:
        sys.exit('Please provide sequence for %s' % seqName)
    # read in data from file
    indexList = []
    valueList = []
    with open(file, 'r') as fin:
        for line in fin:
            fields = line.split()
            assert len(fields) == 5, 'ERROR: wrong data format for %s' % file
            indexList.append( [ np.int16(_)-1 for _ in fields[:2] ] )
            valueList.append( [ np.float16(_) for _ in fields[2:] ] )
    # check matrix index
    indexArr = np.transpose( np.array(indexList) )
    if np.amin(indexArr) < 0 or np.amax(indexArr) >= len(seq):
        sys.exit('ERROR: index out of sequence length for %s' % file)
    # convert data to numpy array
    allPairs = np.zeros((len(seq),len(seq),len(valueList[0])), dtype=np.float16)
    allPairs[ indexArr[0], indexArr[1] ] = valueList # copy data to half matrix
    allPairs[ indexArr[1], indexArr[0] ] = valueList # make the matrix symmetric
    if np.isnan( np.sum( allPairs.astype(np.float32) ) ):
        sys.exit('ERROR: there are NaNs in file %s' % file)

    return allPairs


def ReadFeatures(p=None, DataSourceDir=None):
    if p is None:
        sys.exit('Please specify a valid target name!')
    if DataSourceDir is None:
        sys.exit('Please specify a folder containing all features for target!')
    if not os.path.isdir(DataSourceDir):
        sys.exit('The feature directory does not exist: ', DataSourceDir)

    OneProtein = dict()
    OneProtein['name'] = p

    # read in sequence from .seq file
    fastafh=open(DataSourceDir + p + ".seq", "r")
    fastacontent = [ line.strip() for line in list(fastafh) ]
    if not fastacontent[0].startswith('>'):
        OneProtein['sequence'] = ''.join(fastacontent)
    else:
        OneProtein['sequence'] = ''.join(fastacontent[1: ])
    fastafh.close()

    # read in 3-state secondary structure from .ss3 file
    OneProtein['SS3'] = Load1DFeatureFromFile(file=DataSourceDir+p+".ss3",
                                              seqName=p,
                                              seq=OneProtein['sequence'])

    # read in 8-state secondary structure from .ss8 file
    OneProtein['SS8'] = Load1DFeatureFromFile(file=DataSourceDir+p+".ss8",
                                              seqName=p,
                                              seq=OneProtein['sequence'])

    # read in solvent accessibility from .acc file
    OneProtein['ACC'] = Load1DFeatureFromFile(file=DataSourceDir+p+".acc",
                                              seqName=p,
                                              seq=OneProtein['sequence'])

    # read in disorder prediction from .diso file
    OneProtein['DISO'] = Load1DFeatureFromFile(file=DataSourceDir+p+".diso",
                                               seqName=p,
                                               seq=OneProtein['sequence'])

    """
    # read in PSFM and PSSM from .tgt file
    import subprocess
    import tempfile
    with tempfile.NamedTemporaryFile(delete=True) as tmp:
        # check input file
        tgtf = DataSourceDir + p + ".tgt"
        if not os.path.isfile(tgtf):
            sys.exit('ERROR: cannot find the following file %s' % tgtf)
        # check helper program
        PrintTGT = os.path.abspath(os.path.dirname(__file__)) + "/PrintTGT"
        if not os.path.isfile(PrintTGT):
            sys.exit('ERROR: cannot find the helper program: %s' % PrintTGT)
        # write temporary profile file
        with open(tmp.name, 'w') as fout:
            cmdStr = [PrintTGT, p, DataSourceDir]
            proc = subprocess.Popen(cmdStr, stdout=fout, stderr=fout)
            proc.wait()
            fout.seek(0)
        # read in PSFM and PSSM from temporary profile
        OneProtein['PSFM'], OneProtein['PSSM'] = LoadProfile(
            file=tmp.name,
            seqName=p,
            seq=OneProtein['sequence'])
    """

    # read in PSFM and PSSM from .hhm file
    hhm = LoadHHM(DataSourceDir+p+'.hhm')
    OneProtein['PSFM'] = hhm['PSFM']
    OneProtein['PSSM'] = hhm['PSSM']
    
    # read in evolutionary couplings from .ccmZ file
    OneProtein['ccmpredZ'] = LoadECMatrix(file=DataSourceDir+p+'.ccmZ',
                                          seqName=p,
                                          seq=OneProtein['sequence'])

    # read in contact potential from .pot file
    OneProtein['OtherPairs'] = LoadOtherPairFeatures(file=DataSourceDir+p+'.pot',
                                                     seqName=p,
                                                     seq=OneProtein['sequence'])

    return OneProtein


def main(listFile, featureMetaDir, outPickle):
    print('protein list file=', listFile)
    print('feature directory=', featureMetaDir)
    print('output picklefile=', outPickle)

    # check file and directory
    if not os.path.isdir(featureMetaDir):
        sys.exit('the provided feature folder is invalid: %s' % featureMetaDir)
    if not os.path.isfile(listFile):
        sys.exit('the provided protein list file is invalid: %s' % listFile)
    
    # read in proteins
    with open(listFile, 'r') as fin:
        proteins = [_.strip() for _ in fin]

    # read in features
    pFeatures = []
    for p in proteins:
        thisFeatureDir = featureMetaDir + '/'
        pFeature = ReadFeatures( p=p, DataSourceDir=thisFeatureDir )
        pFeatures.append(pFeature)

        if len(pFeatures) % 500 == 0:
            print('finished loading features for ', len(pFeatures), ' proteins')

    # writing the result to pickle file
    with open(outPickle, 'wb') as fout:
        pickle.dump( pFeatures, fout )


if __name__ == "__main__":
    if len(sys.argv) != 4:
        sys.exit( """Usage: {} <listFile> <featureMetaDir> <outPickle>
    listFile:        the file containing a list of proteins, each protein
                     name in one line
    featureMetaDir:  specify a folder containing all the features, under
                     which each protein has an independent feature folder
                     named after feat_proteinName_contact
    outPickle:       the output feature file in pickle format, in which
                     echo protein is one dict, the keys are ['name',
                     'sequence', 'SS3', 'SS8', 'ACC', 'DISO', 'PSFM',
                     'PSSM', 'ccmpredZ', 'OtherPairs']

    This script only reads protein features for distance prediciton.""".format(
        sys.argv[0]) )
    listFile, featureMetaDir, outPickle = sys.argv[1:4]
    
    # read a list of protein features into a single PKL file
    main(listFile, featureMetaDir, outPickle)
